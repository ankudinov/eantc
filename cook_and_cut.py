#!/usr/bin/env python3

__author__ = "Petr Ankudinov, Arista EMEA AS"

"""COOK_AND_CUT.py
    builds AVD vars based on simplified CSV input.

This essential logic of this script is contained in 2 classes:
- Cook - process the data loaded from CSV
- Cut - load the data from CSVs and write the processed data as AVD variables

WARNINGS:
1)
When this script is executed, it can overwrite existing AVD variables in the repository.
There should be no manual changes in the files generated by this script.
To ensure that if manual changes were made, they will not be lost
review the AVD variables diff carefully after the script execution.
2)
This script is not officially maintained,
but has a very simple structure and easy to troubleshoot and customize.
"""

import json
import yaml
import csv
from cookiecutter.main import cookiecutter
import os
import sys
import argparse
import re
import hashlib
import copy

def read_yaml_file(filename, load_all=False):
    with open(filename, mode='r') as f:
        if not load_all:
            yaml_data = yaml.load(f, Loader=yaml.FullLoader)
        else:
            # convert generator to list before returning
            yaml_data = list(yaml.load_all(f, Loader=yaml.FullLoader))
    return yaml_data


def read_csv_file(filename):
    with open(filename, mode='r') as csv_file:
        csv_row_dict_list = list()  # list of key-value pairs produced from every CSV row except header
        # if header contains __CCvar and __CCvalue CSV will be processed vertically
        # each row will be treated as separate variable with a name of __CCvar
        vars_from_csv = dict()
        for row in csv.DictReader(csv_file):
            updated_row_dict = dict()
            for k, v in row.items():
                # remove potential spaces left and right
                k = k.strip()
                if v:
                    v = v.strip()
                updated_row_dict.update({k: v})
            if '__CCkey' in updated_row_dict.keys():
                if not '__CCvalue' in updated_row_dict.keys():
                    sys.exit(
                        f'ERROR: __CCkey is defined without __CCvalue in {csv_file}')
                vars_from_csv.update({updated_row_dict['__CCkey']: updated_row_dict['__CCvalue']})
            else:
                csv_row_dict_list.append(updated_row_dict)

    if len(csv_row_dict_list):
        return csv_row_dict_list
    else:
        return vars_from_csv


# Class Cut methods load the data from CSVs and write the processed data as AVD variables.
class Cut:

    def __init__(self, data_input_directory) -> None:
        # init cookiecutter dict
        # in/out keys help to split processed and unprocessed data
        # and add another nesting level required for lists in cookiecutter.json to work
        self.cookiecutter_vars = {
            'in': dict(),  # unprocessed input data
            'out': dict(),  # processed output data
            # copy real jinja2 templates without rendering
            '_copy_without_render': [
                '*.j2'
            ]
        }

        # load all data from input directory and assign to corresponding dict keys
        data_input_directory_full_path = os.path.join(
            os.getcwd(), data_input_directory)
        if not os.path.isdir(data_input_directory_full_path):
            sys.exit(
                f'ERROR: Can not find data input directory {data_input_directory_full_path}')
        
        # read files from the data input directory and add data to cookiecutter json
        # every file will be added as dictionary with a filename without extension as the parent key
        for a_name in os.listdir(data_input_directory_full_path):
            a_full_path = os.path.join(data_input_directory_full_path, a_name)
            if os.path.isfile(a_full_path):
                if '.csv' in a_name.lower():
                    csv_data = read_csv_file(a_full_path)
                    
                    self.cookiecutter_vars['in'].update({
                        # [:-4] removes .csv
                        a_name.lower()[:-4]: csv_data
                    })
                elif '.yml' in a_name.lower():
                    data_from_yaml = read_yaml_file(a_full_path)
                    self.cookiecutter_vars['in'].update({
                        # [:-4] removes .yml
                        a_name.lower()[:-4]: data_from_yaml
                    })
                elif '.yaml' in a_name.lower():
                    data_from_yaml = read_yaml_file(a_full_path)
                    self.cookiecutter_vars['in'].update({
                        # [:-5] removes .yaml
                        a_name.lower()[:-5]: data_from_yaml
                    })

    def cut(self, cookiecutter_template_directory, cookiecutter_output_dir='.'):
        if not os.path.isdir(cookiecutter_template_directory):
            # if no fullpath specified, build fullpath from cwd
            cookiecutter_template_directory = os.path.join(
                os.getcwd(), cookiecutter_template_directory)
            if not os.path.isdir(cookiecutter_template_directory):
                # log error and exit if specified template directory is not present in cwd
                sys.exit(
                    f'ERROR: cant find cookiecutter template directory {cookiecutter_template_directory}')
        # write cookiecutter.json
        cookiecutter_json_filename = os.path.join(
            cookiecutter_template_directory, 'cookiecutter.json')
        with open(cookiecutter_json_filename, 'w') as cc_json_file:
            json.dump(self.cookiecutter_vars, cc_json_file, indent=4)
        # run cookiecutter to build output data
        cookiecutter(cookiecutter_template_directory, no_input=True,
                    overwrite_if_exists=True, output_dir=cookiecutter_output_dir)


class Cook(Cut):

    def avd_leaf_uplinks(self):
        # build AVD variables for uplinks between leafs and spines

        for leaf_inventory, cabling_plan in [
            ('evpn_vxlan_leaf_inventory', 'evpn_vxlan_cabling_plan'),
        ]:

            for index, leaf in enumerate(self.cookiecutter_vars['in'][leaf_inventory].copy()):
                leaf_hostname = leaf['hostname']
                all_leaf_hostnames = [a_leaf['hostname'] for a_leaf in self.cookiecutter_vars['in'][leaf_inventory]]
                self.cookiecutter_vars['in'][leaf_inventory][index].update({
                    'uplink_switches': list(),
                    'uplink_switch_interfaces': list(),
                    'uplink_interfaces': list(),
                    'mlag_interfaces': list()
                })
                for a_link in self.cookiecutter_vars['in'][cabling_plan]:
                    if a_link['local_switch'] == leaf_hostname:
                        if a_link['remote_switch'] not in all_leaf_hostnames:
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_switches'].append(a_link['remote_switch'])
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_switch_interfaces'].append('Ethernet' + a_link['remote_interface'][1:])
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_interfaces'].append('Ethernet' + a_link['local_interface'][1:])
                        else:
                            self.cookiecutter_vars['in'][leaf_inventory][index]['mlag_interfaces'].append('Ethernet' + a_link['remote_interface'][1:])
                    elif a_link['remote_switch'] == leaf_hostname:
                        if a_link['remote_switch'] not in all_leaf_hostnames:
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_switches'].append(a_link['local_switch'])
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_switch_interfaces'].append('Ethernet' + a_link['local_interface'][1:])
                            self.cookiecutter_vars['in'][leaf_inventory][index]['uplink_interfaces'].append('Ethernet' + a_link['remote_interface'][1:])
                        else:
                            self.cookiecutter_vars['in'][leaf_inventory][index]['mlag_interfaces'].append('Ethernet' + a_link['local_interface'][1:])


if __name__ == "__main__":

    # Get cookiecutter output_directory from CLI argument or default
    parser = argparse.ArgumentParser(
        prog="Cook-and-cut",
        description="This script creates expanded data from cookiecutter templates.")
    parser.add_argument(
        '-in', '--input_directory', default='CSVs',
        help='Directory to keep the AVD repository produced by cookiecutter'
    )
    parser.add_argument(
        '-out', '--output_directory', default='.',
        help='Directory to keep the AVD repository produced by cookiecutter'
    )
    parser.add_argument(
        '-td', '--template_dir', default='.cc',
        help="Cookiecutter template directory"
    )
    args = parser.parse_args()

    cc = Cook(args.input_directory)
    cc.avd_leaf_uplinks()  # build AVD var for uplinks between leafs and spines
    cc.cut(args.template_dir)
